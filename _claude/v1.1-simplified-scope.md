# MELCloud Home v1.1 - Polish & Diagnostics

**Priority:** High
**Estimated Effort:** 1-2 hours (reduced from 4)
**Focus:** Integration polish and diagnostics only

**⚠️ WebSocket DEFERRED to v1.2+** - See `websocket-research-defer.md` for details

---

## Core Value Proposition

**v1.0 Status:** Working well, 60-second polling is reliable
**v1.1 Goal:** Polish integration with better diagnostics and UX improvements

---

## What's IN v1.1 ✅

### 1. Integration Icon (30 minutes)

**Files:**
- `icon.png` (256x256)
- `logo.png` (256x256)

**Options:**
1. Use Mitsubishi Electric logo with attribution
2. Generic heat pump icon (mdi:heat-pump)

**Value:** Fixes 404 error, professional appearance

### 2. Basic Diagnostics (30 minutes)

**File:** `diagnostics.py`

**Data:**
```json
{
  "integration_version": "1.1.0",
  "config_entry": {
    "title": "MELCloud Home",
    "entry_id": "...",
    "unique_id": "user@example.com"
  },
  "devices": {
    "total": 2,
    "types": {"ata": 2}
  },
  "coordinator": {
    "last_update_success": true,
    "last_update_time": "2025-01-17T18:30:00Z",
    "update_interval": 60
  },
  "entities": {
    "climate": 2
  }
}
```

**Value:** Easy troubleshooting, better issue reports

### 3. Documentation Improvements (15 minutes)

**Updates:**
- README with diagnostics instructions
- Troubleshooting section
- Better quickstart guide
- Update KNOWN-ISSUES.md (close icon issue)

---

## Technical Implementation

### File Changes

**NEW:**
- `custom_components/melcloudhome/diagnostics.py` (Diagnostic export)
- `custom_components/melcloudhome/icon.png`
- `custom_components/melcloudhome/logo.png`

**MODIFIED:**
- `custom_components/melcloudhome/manifest.json` (Add diagnostics)
- `README.md` (Documentation updates)
- `_claude/KNOWN-ISSUES.md` (Close icon issue)

### Diagnostics Implementation

```python
class MELCloudHomeWebSocket:
    """Manage WebSocket connection for real-time updates."""

    def __init__(self, coordinator):
        self._coordinator = coordinator
        self._state = "disconnected"
        self._retry_count = 0
        self._max_retries = 6
        self._backoff = [0, 1, 2, 4, 8, 30]  # seconds

    async def connect(self):
        """Connect to WebSocket and start receiving messages."""
        # 1. Get token from /ws/token
        # 2. Connect to wss://ws.melcloudhome.com
        # 3. Authenticate (method TBD from research)
        # 4. Start message loop

    async def _handle_message(self, message):
        """Parse message and update coordinator data."""
        msg_type = message.get("messageType")

        if msg_type == "unitStateChanged":
            # Merge delta into coordinator.data
            device_id = message["Data"]["id"]
            for setting in message["Data"]["settings"]:
                self._merge_setting(device_id, setting)
            self._coordinator.async_set_updated_data(self._coordinator.data)

        elif msg_type == "unitWifiSignalChanged":
            # Update WiFi sensor
            device_id = message["Data"]["id"]
            rssi = message["Data"]["rssi"]
            self._coordinator.data[device_id]["rssi"] = rssi
            self._coordinator.async_set_updated_data(self._coordinator.data)

        elif msg_type == "unitErrorStateChanged":
            # Update error binary sensor
            device_id = message["Data"]["id"]
            is_error = message["Data"]["isError"]
            error_code = message["Data"].get("errorCode")
            self._coordinator.data[device_id]["is_error"] = is_error
            self._coordinator.data[device_id]["error_code"] = error_code
            self._coordinator.async_set_updated_data(self._coordinator.data)

    def _merge_setting(self, device_id, setting):
        """
        Merge single setting into device state with type coercion.

        Critical: API sends inconsistent types (string "True" vs boolean true).
        """
        field_name = setting["name"]
        raw_value = setting["value"]

        # Apply type coercion based on field (see WebSocket Protocol Reference)
        if field_name == "Power":
            value = self._coerce_bool(raw_value)
        elif field_name in ("ActualFanSpeed",):
            value = self._coerce_int(raw_value)
        elif field_name == "SetFanSpeed":
            # Can be "Auto" string or integer
            value = raw_value if raw_value == "Auto" else self._coerce_int(raw_value)
        else:
            value = raw_value

        # Update state (delta merge - don't replace entire device)
        self._coordinator.data[device_id][field_name] = value

    @staticmethod
    def _coerce_bool(value):
        """Handle 'True'/'False' strings and true/false booleans."""
        if isinstance(value, str):
            return value.lower() == "true"
        return bool(value)

    @staticmethod
    def _coerce_int(value):
        """Handle '0'-'5' strings and 0-5 integers."""
        if isinstance(value, str):
            return int(value)
        return value

    async def disconnect(self):
        """Clean disconnect."""
```

### Coordinator Integration (Simplified)

```python
class MELCloudHomeCoordinator(DataUpdateCoordinator):
    """Coordinator with WebSocket support."""

    def __init__(self, hass, client):
        super().__init__(hass, _LOGGER, name=DOMAIN, update_interval=timedelta(seconds=60))
        self._websocket = MELCloudHomeWebSocket(self)
        self._websocket_active = False

    async def _async_setup(self):
        """Setup after first successful update."""
        # Start WebSocket connection
        try:
            await self._websocket.connect()
            self._websocket_active = True
            # Suspend polling while WebSocket active
            self.update_interval = None
        except Exception as e:
            _LOGGER.warning("WebSocket connection failed, using polling: %s", e)
            # Continue with 60s polling

    async def _async_update_data(self):
        """Update data (polling fallback only)."""
        # Only called if WebSocket is not active
        if self._websocket_active:
            # WebSocket is handling updates, skip polling
            return self.data

        # Normal REST API polling
        return await self._fetch_from_rest_api()
```

**Key Simplification:** One active update mechanism at a time. No concurrent handling.

### Sensor Platform

```python
async def async_setup_entry(hass, entry, async_add_entities):
    """Set up WiFi signal sensors."""
    coordinator = hass.data[DOMAIN][entry.entry_id]

    sensors = []
    for device in coordinator.data["devices"]:
        sensors.append(WiFiSignalSensor(coordinator, device))

    async_add_entities(sensors)

class WiFiSignalSensor(CoordinatorEntity, SensorEntity):
    """WiFi signal strength sensor."""

    _attr_device_class = SensorDeviceClass.SIGNAL_STRENGTH
    _attr_native_unit_of_measurement = "dBm"
    _attr_state_class = SensorStateClass.MEASUREMENT
    _attr_has_entity_name = True

    def __init__(self, coordinator, device):
        super().__init__(coordinator)
        self._device = device
        self._attr_unique_id = f"{device['id']}_wifi_signal"
        # Remove "heatpump_" from entity ID
        self._attr_name = "WiFi Signal"  # Device name + this = "{Building} {Room} WiFi Signal"

    @property
    def native_value(self):
        """Return RSSI value."""
        return self.coordinator.data[self._device["id"]].get("rssi")

    @property
    def extra_state_attributes(self):
        """Return quality indicator."""
        rssi = self.native_value
        if rssi is None:
            return {}

        # Quality thresholds
        if rssi >= -50:
            quality = "excellent"
        elif rssi >= -60:
            quality = "good"
        elif rssi >= -70:
            quality = "fair"
        else:
            quality = "poor"

        return {"rssi": rssi, "quality": quality}

    @property
    def icon(self):
        """Dynamic icon based on signal strength."""
        rssi = self.native_value
        if rssi is None:
            return "mdi:wifi-off"
        elif rssi >= -50:
            return "mdi:wifi-strength-4"
        elif rssi >= -60:
            return "mdi:wifi-strength-3"
        elif rssi >= -70:
            return "mdi:wifi-strength-2"
        else:
            return "mdi:wifi-strength-1"
```

---

## Testing Requirements

### Unit Tests (1 hour)

**WebSocket Tests:**
- [ ] Message parsing (all 3 types)
- [ ] Type coercion ("True" → True, "0" → 0)
- [ ] Delta merge logic
- [ ] Reconnection with exponential backoff

**Sensor Tests:**
- [ ] WiFi signal sensor creation
- [ ] RSSI value and quality calculation
- [ ] Icon selection based on signal strength
- [ ] Error binary sensor creation
- [ ] Error state updates

**Coordinator Tests:**
- [ ] WebSocket integration
- [ ] Fallback to polling after WebSocket failure
- [ ] Single active update mechanism

### Integration Tests (30 minutes)

**Manual Testing:**
- [ ] WebSocket connects after integration reload
- [ ] State updates appear < 1 second after change
- [ ] WiFi signal sensor shows correct value
- [ ] Error sensor shows correct state
- [ ] Disconnection triggers reconnection
- [ ] After 6 failures, falls back to polling
- [ ] Entity IDs have no "heatpump_" suffix
- [ ] Integration icon appears (no 404)
- [ ] Diagnostic data downloads successfully

**Long-running:**
- [ ] 24-hour stability test (no memory leaks)
- [ ] WebSocket stays connected overnight

---

## Documentation

### README Updates (30 minutes)

```markdown
## Real-Time Updates ⚡

This integration uses WebSocket for instant state updates:
- State changes appear within **1 second**
- Automatic fallback to 60-second polling if WebSocket fails
- No configuration required

## Sensors

Each device provides:

### Climate Control
- `climate.{building}_{room}` - HVAC control entity

### Connectivity
- `sensor.{building}_{room}_wifi_signal` - WiFi signal strength in dBm
  - Attributes: `rssi`, `quality` (excellent/good/fair/poor)

### Diagnostics
- `binary_sensor.{building}_{room}_error` - Device error indicator
  - Attributes: `error_code`, `error_message`

### Temperature Data

Temperature readings are available via the climate entity:
- Current temperature: `climate.{}.attributes.current_temperature`
- Target temperature: `climate.{}.attributes.temperature`

If you need temperature statistics, create a template sensor:
```yaml
template:
  - sensor:
      - name: "Bedroom Temperature"
        state: "{{ state_attr('climate.home_bedroom', 'current_temperature') }}"
        device_class: temperature
        state_class: measurement
        unit_of_measurement: "°C"
```

## Troubleshooting

### Download Diagnostics

Settings → Devices & Services → MELCloud Home → **Download Diagnostics**

This exports integration state for troubleshooting:
- Device information
- WebSocket connection status
- Recent errors
- Entity counts

### WebSocket Issues

If you see "WebSocket disconnected" in logs:
- Integration will retry automatically (6 attempts)
- Falls back to 60-second polling if connection fails
- Check firewall allows `wss://ws.melcloudhome.com`

## Icon Attribution

Integration icon: [Mitsubishi Electric logo] - Used under fair use for product integration
```

### ADR-005 (15 minutes)

Create `docs/decisions/005-websocket-real-time-updates.md`:
- Context: 60-second polling delay
- Decision: Add WebSocket with polling fallback
- Consequences: Better UX, added complexity
- Alternatives: Polling only, WebSocket only

---

## Timeline

**Total: 4 hours** (reduced from 7)

1. **Research** (30 min) - Capture WebSocket protocol from browser
2. **WebSocket Manager** (1.5 hours) - Connection, message parsing, reconnection
3. **Sensors** (1 hour) - WiFi sensor, error binary sensor, diagnostics
4. **Integration** (30 min) - Coordinator changes, entity naming fix, icon
5. **Testing** (30 min) - Unit tests, integration testing, manual verification

---

## Success Criteria

**Functional:**
- [x] WebSocket connects and receives messages
- [x] State updates within 1 second
- [x] WiFi sensor and error sensor working
- [x] Falls back to polling on WebSocket failure
- [x] Entity IDs simplified (no "heatpump_")
- [x] Integration icon shows (no 404)
- [x] Diagnostic data exports

**Quality:**
- [x] All tests passing (>80% coverage)
- [x] No memory leaks (24-hour test)
- [x] Clean logs (no unnecessary warnings)

**User Experience:**
- [x] Instant updates visible
- [x] No configuration needed
- [x] Reliable for 24+ hours
- [x] Graceful fallback on errors

---

## WebSocket Protocol Reference

### Connection Details

**URL:** `wss://ws.melcloudhome.com`

**Token Endpoint:** `GET /ws/token`
**Token Format:**
```json
{
  "hash": "uuid",
  "userId": "uuid"
}
```

### Message Types (Captured from Browser)

#### Message Type 1: `unitStateChanged`

State updates (can be delta or full):

```json
{
  "messageType": "unitStateChanged",
  "Data": {
    "id": "device-uuid",
    "unitType": "ata",
    "settings": [
      {"name": "Power", "value": "True" | true | "False" | false},
      {"name": "OperationMode", "value": "Heat" | "Cool" | "Automatic" | "Dry" | "Fan"},
      {"name": "ActualFanSpeed", "value": "0" | 0 | "1" | "2" | "3" | "4" | "5"},
      {"name": "SetFanSpeed", "value": 0 | "Auto" | 1 | 2 | 3 | 4 | 5},
      {"name": "VaneHorizontalDirection", "value": "Auto" | "Swing" | "One" | "Two" | "Three" | "Four" | "Five"},
      {"name": "VaneVerticalDirection", "value": "Auto" | "Swing" | "One" | "Two" | "Three" | "Four" | "Five"},
      {"name": "InStandbyMode", "value": true | false},
      {"name": "SetTemperature", "value": 10.0-31.0},
      {"name": "RoomTemperature", "value": number}
    ]
  }
}
```

**Characteristics:**
- Can be **delta** (1-2 fields) or **full** (all fields)
- **Data types are inconsistent** (critical implementation detail):
  - Power: Sometimes string `"True"/"False"`, sometimes boolean `true/false`
  - Fan speeds: Sometimes string `"0"`, sometimes integer `0`
  - Need type coercion on every field
- Updates arrive within 1 second of state change

**Delta Handling:**
- Must merge delta into existing coordinator data
- Missing fields = no change (not null)
- Never replace entire device state with partial update

#### Message Type 2: `unitWifiSignalChanged`

WiFi signal strength updates:

```json
{
  "messageType": "unitWifiSignalChanged",
  "Data": {
    "id": "device-uuid",
    "rssi": -53,
    "unitType": "ata"
  }
}
```

**Characteristics:**
- RSSI in dBm (-90 to -30 typical range)
- Updates periodically or on significant change

#### Message Type 3: `unitErrorStateChanged`

Error state notifications:

```json
{
  "messageType": "unitErrorStateChanged",
  "Data": {
    "id": "device-uuid",
    "unitType": "ata",
    "isError": true | false,
    "errorCode": "string"
  }
}
```

**Characteristics:**
- Instant error notifications
- Error code format TBD (need to capture actual errors)

### Type Coercion Requirements

**Critical:** API sends inconsistent data types for same fields

**Implementation must handle:**
```python
def coerce_bool(value):
    """Handle 'True'/'False' strings and true/false booleans."""
    if isinstance(value, str):
        return value.lower() == "true"
    return bool(value)

def coerce_int(value):
    """Handle '0'-'5' strings and 0-5 integers."""
    if isinstance(value, str):
        return int(value)
    return value
```

**Fields requiring coercion:**
- `Power`: string → bool
- `ActualFanSpeed`: string → int
- `SetFanSpeed`: mixed (can be "Auto" string or int)
- `InStandbyMode`: sometimes bool

### Delta Merge Algorithm

```python
def merge_delta(current_state: dict, delta_settings: list) -> dict:
    """
    Merge WebSocket delta into current device state.

    Args:
        current_state: Current device state from coordinator
        delta_settings: List of {"name": field, "value": value} from WebSocket

    Returns:
        Updated device state
    """
    for setting in delta_settings:
        field_name = setting["name"]
        raw_value = setting["value"]

        # Apply type coercion based on field
        if field_name == "Power":
            value = coerce_bool(raw_value)
        elif field_name in ("ActualFanSpeed",):
            value = coerce_int(raw_value)
        elif field_name == "SetFanSpeed":
            # Can be "Auto" or integer
            value = raw_value if raw_value == "Auto" else coerce_int(raw_value)
        else:
            value = raw_value

        # Update state
        current_state[field_name] = value

    return current_state
```

### Reconnection Strategy

**Exponential backoff:**
```
Attempt 1: Immediate (0 seconds)
Attempt 2: 1 second
Attempt 3: 2 seconds
Attempt 4: 4 seconds
Attempt 5: 8 seconds
Attempt 6+: 30 seconds
```

**After 6 failures:** Fall back to 60-second polling

## Open Questions (Research Phase)

**OQ-1: WebSocket Authentication**
- Query parameter? `wss://ws.melcloudhome.com?token={hash}`
- Header? `Authorization: Bearer {hash}`
- First message? `{"auth": "{hash}"}`
- **Resolution:** Capture from browser DevTools Network → WS tab

**OQ-2: Token Expiration**
- How long is the WebSocket token valid?
- Same as REST API session?
- Does WebSocket send refresh/reconnect messages?
- **Resolution:** Monitor token lifecycle in browser, check for refresh messages

**OQ-3: Subscription Model**
- Auto-subscribe to all devices on connection?
- Manual subscription message per device?
- Manual subscription per building?
- **Resolution:** Capture WebSocket handshake frames in DevTools

**OQ-4: Heartbeat/Keepalive**
- Does server send ping frames?
- Does client need to send keepalive?
- What interval?
- **Resolution:** Monitor long-running WebSocket connection (10+ minutes)

---

## Next Step

**Start Phase 1: Research** (30 minutes)
- Open Chrome DevTools on melcloudhome.com
- Go to Network → WS tab
- Capture WebSocket frames
- Document authentication and handshake

Then return for Phase 2 implementation approval.

---

## Deferred Features

See `_claude/ROADMAP.md` for features deferred to v1.2+
