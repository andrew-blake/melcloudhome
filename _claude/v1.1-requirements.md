# MELCloud Home v1.1 Requirements

**Version:** 1.1.0
**Priority:** High
**Estimated Effort:** 7 hours
**Target:** v1.1 release

---

## Overview

Enhance the MELCloud Home integration with:
- **Real-time updates** via WebSocket (eliminate 60-second polling delay)
- **New sensor platforms** (temperature, WiFi signal, energy consumption)
- **Binary sensor platform** (error state monitoring)
- **Energy Dashboard integration** (cumulative energy tracking)

---

## Business Requirements

### BR-1: Real-Time Updates

- **Requirement:** Device state changes must be reflected in Home Assistant within 1 second
- **Current:** 60-second polling interval
- **Benefit:** Better user experience, faster automations

### BR-2: WiFi Signal Monitoring

- **Requirement:** Expose WiFi signal strength as a sensor entity
- **Use Case:** Monitor device connectivity health
- **Benefit:** Troubleshoot connectivity issues

### BR-3: Error State Monitoring

- **Requirement:** Expose device error states as binary sensor
- **Use Case:** Get notified of device errors immediately
- **Benefit:** Proactive maintenance

### BR-4: Reduced API Load

- **Requirement:** Minimize REST API polling when WebSocket is active
- **Current:** 1 request per device every 60 seconds
- **Benefit:** Lower rate limit risk, reduced server load

### BR-5: Integration Icon

- **Requirement:** Integration should have a proper icon (no 404 error)
- **Current:** Icon shows 404 from brands.home-assistant.io
- **Benefit:** Professional appearance, better UX

### BR-6: Diagnostic Data

- **Requirement:** Provide diagnostic data for troubleshooting
- **Current:** No diagnostic data export
- **Benefit:** Easier issue reporting and debugging

---

## Technical Requirements

### TR-1: WebSocket Connection

**Connection Details:**

- **URL:** `wss://ws.melcloudhome.com`
- **Authentication:** Token from `GET /ws/token`
- **Token Format:**

  ```json
  {
    "hash": "uuid",
    "userId": "uuid"
  }
  ```

- **Headers:** TBD (need to capture from browser)
- **Protocol:** Standard WebSocket (RFC 6455)

**Connection Lifecycle:**

1. Fetch token from `/ws/token`
2. Connect to `wss://ws.melcloudhome.com`
3. Authenticate (method TBD)
4. Start receiving messages
5. Handle disconnections and reconnect

**Requirements:**

- MUST reconnect automatically on disconnect
- MUST handle token expiration and refresh
- MUST fall back to polling if WebSocket fails
- MUST clean up on integration unload

### TR-2: Message Types

**Message Type 1: `unitStateChanged`**

State updates (delta or full):

```json
{
  "messageType": "unitStateChanged",
  "Data": {
    "id": "device-uuid",
    "unitType": "ata",
    "settings": [
      {"name": "Power", "value": "True" | true | "False" | false},
      {"name": "OperationMode", "value": "Heat" | "Cool" | "Automatic" | "Dry" | "Fan"},
      {"name": "ActualFanSpeed", "value": "0" | 0 | "1-5"},
      {"name": "SetFanSpeed", "value": 0 | "Auto" | 1-5},
      {"name": "VaneHorizontalDirection", "value": "Auto" | "Swing" | "One-Five"},
      {"name": "VaneVerticalDirection", "value": "Auto" | "Swing" | "One-Five"},
      {"name": "InStandbyMode", "value": true | false},
      {"name": "SetTemperature", "value": 10.0-31.0},
      {"name": "RoomTemperature", "value": number}
    ]
  }
}
```

**Characteristics:**

- Can be **delta** (1 field) or **full** (all fields)
- Data types are **inconsistent** (strings, booleans, integers)
- Updates arrive within 1 second of state change

**Message Type 2: `unitWifiSignalChanged`**

WiFi signal strength updates:

```json
{
  "messageType": "unitWifiSignalChanged",
  "Data": {
    "id": "device-uuid",
    "rssi": -53,
    "unitType": "ata"
  }
}
```

**Characteristics:**

- RSSI in dBm (-90 to -30 typical range)
- Updates periodically or on significant change

**Message Type 3: `unitErrorStateChanged`**

Error state notifications:

```json
{
  "messageType": "unitErrorStateChanged",
  "Data": {
    "id": "device-uuid",
    "unitType": "ata",
    "isError": true | false,
    "errorCode": "string"
  }
}
```

**Characteristics:**

- Instant error notifications
- Error code format TBD

### TR-3: Data Handling

**Delta Updates:**

- WebSocket messages MAY contain partial state (delta)
- MUST merge delta into existing coordinator data
- MUST NOT replace entire device state with partial update
- Missing fields = no change (not null)

**Full Updates:**

- WebSocket messages MAY contain complete state
- Can safely replace device state
- Occurs on initial connection or after reconnect

**Type Coercion:**

- MUST handle inconsistent data types:
  - `"True"` string → `true` boolean
  - `"0"` string → `0` integer
  - Mixed types for same field

**Merge Strategy:**

```python
# Pseudocode
def merge_delta(current_state, delta_settings):
    for setting in delta_settings:
        field = setting["name"]
        value = coerce_type(field, setting["value"])
        current_state[field] = value
    return current_state
```

### TR-4: Coordinator Integration

**Hybrid Approach:**

- WebSocket for real-time updates (primary)
- REST API polling as fallback (secondary)
- Initial state from REST API

**Requirements:**

- MUST load initial state from REST API
- MUST update coordinator data from WebSocket deltas
- MUST fall back to polling if WebSocket disconnects
- MUST handle concurrent updates (WebSocket + polling)
- MUST avoid duplicate refreshes

**State Machine:**

```
[Initial] → [Fetch REST] → [Connect WebSocket] → [Active]
                ↑                                      ↓
                └──────────[Disconnected]←─────────────┘
                           ↓ (after retry limit)
                      [Polling Fallback]
```

### TR-5: New Sensor Entities

#### 5.1 WiFi Signal Sensor

- **Entity ID:** `sensor.{building}_{room}_heatpump_wifi_signal`
- **Device Class:** `signal_strength`
- **Unit:** dBm
- **State:** Integer (-90 to -30)
- **State Class:** `measurement`
- **Icon:** `mdi:wifi-strength-{1-4}`
- **Attributes:**
  - `rssi`: Raw RSSI value
  - `quality`: "excellent" | "good" | "fair" | "poor"
- **Update Source:** WebSocket `unitWifiSignalChanged` messages

#### 5.2 Current Temperature Sensor

- **Entity ID:** `sensor.{building}_{room}_heatpump_current_temperature`
- **Device Class:** `temperature`
- **Unit:** °C
- **State:** Float (temperature)
- **State Class:** `measurement` (enables statistics!)
- **Precision:** 0.5°C
- **Icon:** `mdi:thermometer`
- **Update Source:** WebSocket `unitStateChanged` → `RoomTemperature` field
- **Rationale:** Required for statistics-based chart cards and historical analysis

#### 5.3 Target Temperature Sensor

- **Entity ID:** `sensor.{building}_{room}_heatpump_target_temperature`
- **Device Class:** `temperature`
- **Unit:** °C
- **State:** Float (temperature)
- **State Class:** `measurement`
- **Precision:** 0.5°C
- **Icon:** `mdi:thermometer-auto`
- **Update Source:** WebSocket `unitStateChanged` → `SetTemperature` field
- **Rationale:** Track setpoint changes over time for analysis

#### 5.4 Energy Consumption Sensor

- **Entity ID:** `sensor.{building}_{room}_heatpump_energy`
- **Device Class:** `energy`
- **Unit:** kWh (converted from Wh)
- **State:** Float (cumulative kWh)
- **State Class:** `total_increasing` (enables Energy Dashboard)
- **Icon:** `mdi:lightning-bolt`
- **Attributes:**
  - `finalized_kwh`: Finalized cumulative total (completed hours only)
  - `current_hour_wh`: Current hour in progress (Wh, not finalized)
  - `current_hour_timestamp`: Timestamp of current hour
  - `last_update`: Last API poll time
- **Update Source:** REST API polling (not WebSocket)
- **Polling Interval:** 15 minutes (configurable)
- **API Endpoint:** `GET /api/telemetry/energy/{deviceId}`
- **API Parameters:**
  - `from`: Start time (now - 24 hours)
  - `to`: End time (now)
  - `interval`: "Hour"
  - `measure`: "cumulative_energy_consumed_since_last_upload"

**Energy Sensor Requirements:**

- MUST convert Wh to kWh (divide by 1000)
- MUST handle API data format: "cumulative since last upload" that resets
- MUST track finalized vs current hour separately
- MUST NOT double-count when current hour updates
- MUST NOT restate history
- MUST persist across HA restarts
- MUST track forward only (no historical backfill)

**Energy Tracking Algorithm:**

```python
# Separate finalized hours from current incomplete hour
- Finalized hours: Completed, added once, never updated
- Current hour: Tracked separately, NOT added to total yet
- When hour completes: Move to finalized, add to total once

# Example timeline:
17:15 Poll - {time: "17:00", value: 100 Wh}
  → Current hour: 100 Wh (not added)
  → Total: 10.5 kWh

17:45 Poll - {time: "17:00", value: 200 Wh}
  → Current hour: 200 Wh (updated, not added)
  → Total: 10.5 kWh (unchanged)

18:05 Poll - {time: "17:00", value: 250 Wh}, {time: "18:00", value: 10 Wh}
  → Finalize 17:00: +0.25 kWh
  → Total: 10.75 kWh
  → Current hour: 10 Wh (18:00, not added)
```

**Energy Storage:**

- Store `_total_kwh` in sensor state
- Store `_finalized_hours` dict in attributes
- Restore on HA restart
- Do NOT restore current hour (may have completed)

#### 5.5 Error State Binary Sensor

- **Entity ID:** `binary_sensor.{building}_{room}_heatpump_error`
- **Device Class:** `problem`
- **State:** `on` (error) | `off` (normal)
- **Attributes:**
  - `error_code`: Error code string
  - `error_message`: Human-readable message (if available)
- **Update Source:** WebSocket `unitErrorStateChanged` messages

### TR-6: Error Handling

**Connection Errors:**

- MUST retry connection with exponential backoff
- MUST log connection failures
- MUST fall back to polling after N failed attempts
- MUST expose connection state as diagnostic

**Message Parsing Errors:**

- MUST log unparsable messages
- MUST NOT crash on malformed messages
- MUST continue processing other messages
- MUST expose parse error count as diagnostic

**Data Consistency:**

- MUST handle out-of-order messages
- MUST validate device IDs exist
- MUST handle unknown message types gracefully

**Reconnection Strategy:**

```
Attempt 1: Immediate
Attempt 2: 1 second
Attempt 3: 2 seconds
Attempt 4: 4 seconds
Attempt 5: 8 seconds
Attempt 6+: 30 seconds
After 6 failures: Fall back to polling
```

### TR-7: Configuration

**User Configuration:**

- No user configuration required
- WebSocket enabled by default
- Falls back to polling automatically

**Developer Configuration:**

- Add constant: `WEBSOCKET_ENABLED = True`
- Add constant: `WEBSOCKET_RECONNECT_DELAY = [0, 1, 2, 4, 8, 30]`
- Add constant: `WEBSOCKET_MAX_RETRIES = 6`
- Add constant: `ENERGY_POLL_INTERVAL = timedelta(minutes=15)`
- Add constant: `ENERGY_API_INTERVAL = "Hour"  # or "Day"`
- Add constant: `ENERGY_HISTORY_HOURS = 24`

### TR-8: Diagnostic Data Export

**Requirements:**

- MUST implement `async_get_config_entry_diagnostics()` in `__init__.py`
- MUST redact sensitive data (email, passwords, tokens)
- MUST include integration version
- MUST include device counts
- MUST include WebSocket state
- MUST include error information

**Diagnostic Data Structure:**

```json
{
  "integration_version": "1.1.0",
  "config_entry": {
    "title": "MELCloud Home",
    "entry_id": "...",
    "unique_id": "user@example.com"  // Email (safe to include)
  },
  "devices": {
    "total_count": 2,
    "by_type": {
      "ata": 2
    },
    "buildings": ["Home", "Office"]
  },
  "coordinator": {
    "last_update_success": true,
    "last_update_time": "2025-11-17T16:00:00Z",
    "update_interval": 60,
    "last_exception": null
  },
  "websocket": {
    "enabled": true,
    "state": "connected",
    "url": "wss://ws.melcloudhome.com",
    "uptime_seconds": 3600,
    "messages_received": 1234,
    "messages_by_type": {
      "unitStateChanged": 800,
      "unitWifiSignalChanged": 400,
      "unitErrorStateChanged": 34
    },
    "parse_errors": 0,
    "reconnection_attempts": 2,
    "last_error": null,
    "last_error_time": null
  },
  "energy_tracking": {
    "enabled": true,
    "poll_interval": 900,  // seconds
    "devices_tracked": 2,
    "last_poll": "2025-11-17T16:15:00Z",
    "finalized_hours_count": 24,
    "current_hour_in_progress": true
  },
  "sensors": {
    "climate": 2,
    "sensor": 8,  // 4 per device (wifi, current_temp, target_temp, energy)
    "binary_sensor": 2  // 1 per device (error)
  }
}
```

**Diagnostic Access:**

Users access via: Settings → Devices & Services → MELCloud Home → "Download Diagnostics"

### TR-9: Integration Icon

**Requirements:**

- MUST provide local icon files (not rely on brands repository)
- Icon format: PNG, 256x256 pixels minimum
- File locations:
  - `custom_components/melcloudhome/icon.png` (square icon)
  - `custom_components/melcloudhome/logo.png` (brand logo)
- MUST be recognizable as Mitsubishi Electric or MELCloud
- SHOULD follow HA icon guidelines

**Options:**

1. Use Mitsubishi Electric logo (with attribution)
2. Create custom MELCloud Home icon
3. Use generic heat pump icon

**Recommendation:** Option 1 - Use official ME logo with attribution in README

**File Requirements:**
- Format: PNG with transparency
- Size: 256x256 minimum (512x512 preferred)
- Color: Full color or white/transparent for dark mode
- License: Verify usage rights or fair use

---

## Implementation Requirements

### IM-1: Dependencies

**Add to `manifest.json`:**

- `aiohttp` (already available in HA)
- `websockets` (if not using aiohttp WebSocket client)

**Prefer:** Use `aiohttp` WebSocket client (already in HA core)

### IM-2: File Structure

```
custom_components/melcloudhome/
├── websocket.py                 # NEW: WebSocket manager
├── coordinator.py               # MODIFY: Add WebSocket + energy polling
├── sensor.py                    # NEW: WiFi, temperature, energy sensors
├── binary_sensor.py             # NEW: Error state binary sensor
├── energy_tracker.py            # NEW: Energy tracking logic
├── diagnostics.py               # NEW: Diagnostic data export
├── const.py                     # MODIFY: Add WebSocket + energy constants
├── icon.png                     # NEW: Integration icon (256x256+)
├── logo.png                     # NEW: Integration logo (256x256+)
└── manifest.json                # MODIFY: Add sensor/binary_sensor platforms
```

### IM-3: API Client Changes

**Add to `client.py`:**

```python
async def get_ws_token(self) -> dict:
    """Get WebSocket authentication token."""
    # GET /ws/token
    # Returns: {"hash": "uuid", "userId": "uuid"}

async def get_energy_data(
    self,
    device_id: str,
    from_time: datetime,
    to_time: datetime,
    interval: str = "Hour"
) -> list[dict]:
    """
    Get energy consumption data.

    Args:
        device_id: Device UUID
        from_time: Start datetime
        to_time: End datetime
        interval: "Hour" or "Day"

    Returns:
        List of {time: str, value: str} readings in Wh
    """
    # GET /api/telemetry/energy/{device_id}?from=...&to=...&interval=...
```

### IM-4: Coordinator Changes

**Modify `coordinator.py`:**

- Add WebSocket manager initialization
- Add message handler methods
- Add delta merge logic
- Add fallback logic
- Maintain polling as backup

### IM-5: New Sensor Platform

**Create `sensor.py`:**

- WiFi signal strength sensor (WebSocket updates)
- Current temperature sensor (WebSocket updates)
- Target temperature sensor (WebSocket updates)
- Energy consumption sensor (REST API polling)
- Implement `RestoreEntity` for energy sensor
- Handle missing data gracefully

### IM-6: New Binary Sensor Platform

**Create `binary_sensor.py`:**

- Error state binary sensor
- Update from WebSocket messages
- Default to "off" (no error)

---

## Testing Requirements

### TE-1: Unit Tests

**WebSocket Manager Tests:**

- [ ] Connection establishment
- [ ] Token authentication
- [ ] Message parsing (all types)
- [ ] Type coercion (string → bool, string → int)
- [ ] Delta merging
- [ ] Disconnection handling
- [ ] Reconnection logic
- [ ] Error handling

**Coordinator Tests:**

- [ ] WebSocket integration
- [ ] Fallback to polling
- [ ] Concurrent updates
- [ ] State consistency

**Sensor Tests:**

- [ ] WiFi signal sensor creation and updates
- [ ] RSSI value updates and quality calculation
- [ ] Current temperature sensor creation and updates
- [ ] Target temperature sensor creation and updates
- [ ] Energy sensor creation
- [ ] Energy tracking algorithm (finalized vs current)
- [ ] Energy deduplication (no double-counting)
- [ ] Energy persistence across restarts
- [ ] Energy current hour updates
- [ ] Energy hour finalization
- [ ] Error binary sensor creation and updates

### TE-2: Integration Tests

**Manual Testing Checklist:**

- [ ] WebSocket connects after integration setup
- [ ] State updates appear within 1 second
- [ ] Delta updates merge correctly
- [ ] Full updates replace state correctly
- [ ] WiFi signal sensor shows correct value
- [ ] Error sensor shows correct state
- [ ] Disconnection triggers reconnection
- [ ] Failed reconnection falls back to polling
- [ ] Integration reload cleans up WebSocket
- [ ] No memory leaks on long-running connection

**Scenarios to Test:**

1. Normal operation with WebSocket active
2. WebSocket disconnection and reconnection
3. WebSocket failure and polling fallback
4. Multiple devices updating simultaneously
5. Rapid state changes (stress test)
6. Integration reload during active WebSocket
7. Home Assistant restart

### TE-3: VCR Testing

**Note:** WebSocket cannot be recorded with VCR

**Strategy:**

- Mock WebSocket connection for tests
- Record initial REST API state only
- Test WebSocket logic with mocked messages

---

## Documentation Requirements

### DO-1: Code Documentation

- Docstrings for all WebSocket classes/methods
- Comments explaining delta merge logic
- Comments explaining type coercion
- Comments explaining reconnection strategy

### DO-2: User Documentation

**Update `README.md`:**

- Mention WebSocket support
- Explain real-time updates
- Document new sensor entities
- Explain fallback behavior

**Example:**

```markdown
## Real-Time Updates

This integration uses WebSocket for instant state updates:
- State changes appear within 1 second
- Automatic fallback to polling if WebSocket fails
- No configuration required

## Sensors

**Temperature Sensors:**
- `sensor.{room}_heatpump_current_temperature` - Room temperature (enables statistics)
- `sensor.{room}_heatpump_target_temperature` - Setpoint temperature

**WiFi Signal:**
- `sensor.{room}_heatpump_wifi_signal` - Signal strength in dBm

**Energy:**
- `sensor.{room}_heatpump_energy` - Cumulative energy consumption in kWh
- Updates every 15 minutes
- Compatible with Energy Dashboard

**Error State:**
- `binary_sensor.{room}_heatpump_error` - Device error indicator
```

### DO-3: Technical Documentation

**Create `_claude/websocket-implementation.md`:**

- WebSocket protocol details
- Connection authentication method
- Message format specifications
- Delta merge algorithm
- Troubleshooting guide

### DO-4: ADR

**Create ADR-005: WebSocket Real-Time Updates**

- Context: 60-second polling delay
- Decision: Add WebSocket support
- Consequences: Complexity vs instant updates
- Alternatives considered: Polling only

---

## Security Requirements

### SE-1: Token Handling

- MUST NOT log WebSocket token
- MUST refresh token on expiration
- MUST clear token on integration unload

### SE-2: Connection Security

- MUST use WSS (not WS)
- MUST validate SSL certificates
- MUST handle SSL errors gracefully

---

## Performance Requirements

### PE-1: Resource Usage

- WebSocket connection MUST NOT consume > 5MB memory
- Message processing MUST complete < 100ms
- Reconnection MUST NOT block coordinator
- MUST NOT create more than 1 WebSocket per integration

### PE-2: Scalability

- MUST support up to 50 devices per integration
- MUST handle 100 messages/second burst
- MUST process messages asynchronously

---

## Migration Requirements

### MI-1: Backward Compatibility

- MUST NOT break existing installations
- MUST work with current polling-only deployments
- WebSocket MUST be opt-in or auto-enabled

### MI-2: Upgrade Path

- No configuration changes required
- No entity ID changes
- Existing entities continue working
- New sensors added automatically

---

## Success Criteria

### SC-1: Functional

- [ ] WebSocket connects successfully
- [ ] All message types parsed correctly
- [ ] State updates within 1 second
- [ ] Delta updates merge correctly
- [ ] Sensors created and updated
- [ ] Fallback to polling works
- [ ] Reconnection works reliably

### SC-2: Quality

- [ ] All tests passing
- [ ] No memory leaks
- [ ] No crashes on malformed messages
- [ ] Proper error logging
- [ ] Code coverage > 80%

### SC-3: Documentation

- [ ] README updated
- [ ] Code documented
- [ ] ADR created
- [ ] Technical docs complete

### SC-4: User Experience

- [ ] Instant state updates visible
- [ ] No configuration needed
- [ ] Works reliably for 24+ hours
- [ ] Falls back gracefully on errors

---

## Open Questions

### OQ-1: WebSocket Authentication

**Question:** How does the WebSocket authenticate using the token?

- Query parameter? `wss://ws.melcloudhome.com?token={hash}`
- Header? `Authorization: Bearer {hash}`
- First message? `{"auth": "{hash}"}`

**Resolution:** Need to capture from browser WebSocket frames

### OQ-2: Token Expiration

**Question:** How long is the WebSocket token valid?

- Same as REST API session?
- Separate expiration?
- Does WebSocket send refresh messages?

**Resolution:** Monitor token lifecycle in browser

### OQ-3: Subscription Model

**Question:** Does WebSocket require subscribing to devices?

- Auto-subscribe to all devices?
- Send subscription message for each device?
- Send for each building?

**Resolution:** Need to capture WebSocket handshake

### OQ-4: Heartbeat/Keepalive

**Question:** Does WebSocket require ping/pong?

- Server-initiated pings?
- Client-initiated keepalive?
- What interval?

**Resolution:** Monitor long-running WebSocket connection

---

## Timeline

**Phase 1: Research** (1 hour)

- Capture WebSocket authentication
- Document handshake protocol
- Capture all message types
- Identify subscription model

**Phase 2: Implementation** (4 hours)

- WebSocket manager class
- Energy tracker class
- Coordinator integration (WebSocket + energy polling)
- Sensor platforms (5 sensor types)
- Binary sensor platform
- Diagnostics implementation
- Error handling
- Integration icon (download/create)

**Phase 3: Testing** (1 hour)

- Unit tests
- Integration tests
- Manual testing
- Diagnostic data verification

**Phase 4: Documentation** (1 hour)

- Update README
- Create ADR-005
- Technical documentation
- Icon attribution

**Total: 7 hours**

---

## Next Steps

1. **Capture WebSocket details** (browser DevTools)
   - Authentication method
   - Handshake messages
   - Subscription protocol
   - Ping/pong messages

2. **Answer open questions**
   - Complete OQ-1 through OQ-4

3. **Review requirements** (this document)
   - Validate with user
   - Confirm priorities
   - Adjust timeline

4. **Begin implementation**
   - After requirements approved

---

## Related Documents

- **v1.2+ Planning:** See `_claude/ROADMAP.md` for future features and HACS distribution
- **Current Issues:** See `_claude/KNOWN-ISSUES.md` for v1.0 open issues
- **API Documentation:** See `_claude/melcloudhome-api-reference.md`
- **Decisions:** See `docs/decisions/` for ADRs
